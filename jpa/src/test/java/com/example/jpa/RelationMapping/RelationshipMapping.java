package com.example.jpa.RelationMapping;

public class RelationshipMapping {
    /*
    연관관계 매핑시 고려사항 3가지
        1. 다중성
            ● N 대 1: @ManyToOne
                - N 대 1 단방향
                    • 가장 많이 사용하는 연관관계
                    • N : 1 의 반대는 1 : N
                - N 대 1 양방향
                    • 외래 키가 있는 쪽이 연관관계의 주인
                    • 양쪽을 서로 참조하도록 개발

            ● 1 대 N: @OneToMany - oneToMany 패키지 참조
                - 1 대 N 단방향(@ManyToOne 으로 인해 @OneToMany(mappedBy) 로 양방향으로 연결된게 아닌 @OneToMany 로 단방향 연결)
                    • 1 : N 단방향은 1이 연관관계의 주인
                    • 테이블 기준으로 1 대 N 관계는 항상 N 쪽에 외래 키가 있음
                    • 객체와 테이블의 차이 때문에 반대편 테이블의 외래 키를 관리하는 특이한 구조(연관관계 관리를 위해 추가로 UPDATE 쿼리가 실행)
                    • @JoinColumn 을 꼭 사용해야 함. 그렇지 않으면 조인 테이블 방식을 사용함(중간에 테이블을 하나 추가함)
                - 1 대 N 양방향
                    • 이런 매핑은 공식적으로 존재X
                    • 읽기 전용 필드를 사용해서 양방향 처럼 사용하는 방법 ==> @JoinColumn(name="", insertable=false, updatable=false)
                    • ★★★ @ManyToOne 을 통해 양방향 관계로 매핑 권장 ★★★

            ● 1 대 1: @OneToOne - oneToOne 패키지 참조
                • 일대일 관계는 그 반대도 일대일
                • 주 테이블이나 대상 테이블 중에 외래 키 선택 가능
                    1-1) 주 테이블에 외래 키 단방향(member 테이블에 locker_id 존재)
                        • 다대일(@ManyToOne) 단방향 매핑과 유사
                    1-2) 주 테이블에 외래 키 양방향(member 테이블에 locker_id 존재)
                        • 다대일 양방향 매핑 처럼 외래 키가 있는 곳이 연관관계의 주인
                        • 반대편은 mappedBy 적용
                    2-1) 대상 테이블에 외래 키 단방향(locker 테이블에 member_id 존재)
                        • 단방향 관계는 JPA 지원X
                        • 양방향 관계는 지원
                    2-2) 대상 테이블에 외래 키 양방향
                        • 일대일 주 테이블에 외래 키 양방향과 매핑 방법은 같음
                • 외래 키에 데이터베이스 유니크(UNI) 제약조건 추가

                ※ 정리
                - 주 테이블(자주 조회하는 테이블)에 외래 키(member 테이블에 locker_id 존재)
                    • 주 객체가 대상 객체의 참조를 가지는 것 처럼 주 테이블에 외래 키를 두고 대상 테이블을 찾음
                    • 객체지향 개발자 선호
                    • JPA 매핑 편리
                    • 장점: 주 테이블만 조회해도 대상 테이블에 데이터가 있는지 확인 가능
                    • 단점: 값이 없으면 외래 키에 null 허용
                    • 주 테이블에 외래 키가 단방향이면 N : 1 양방향 매핑과 유사
                    • 주 테이블에 외래 키가 양방향이면 외래 키가 있는 곳이 연관관계의 주인(반대편은 mappedBy 적용)

                - 대상 테이블에 외래 키(locker 테이블에 member_id 존재)
                    • 대상 테이블에 외래 키가 존재
                    • 전통적인 데이터베이스 개발자 선호
                    • 장점: 주 테이블과 대상 테이블을 1 : 1에서 1 : N 관계로 변경할 때 테이블 구조 유지
                    • 단점: 프록시 기능의 한계로 지연 로딩으로 설정해도 항상 즉시 로딩됨 ==>
                    member 테이블에 locker_id가 존재한다면 member 테이블만 조회해도 locker 의 유무를 알 수 있다.
                    반대로 locker 테이블에 member_id 가 존재한다면 member 테이블만 조회해서는 locker 의 유무를 알 수 없다.
                    그렇기 때문에 확인을 하기 위해서 locker 테이블에 대해 쿼리가 실행되는데 어차피 쿼리가 실행되기때문에 프록시로 만들 이유가 없다.
                    • 대상 테이블에 외래 키가 단방향인 경우는 지원하지 않는다.(양방향만 지원)

                ※ 자신의 테이블에 있는 외래키는 자신이 관리 해야한다.

            ● N 대 M: @ManyToMany
                • 관계형 데이터베이스는 정규화된 테이블 2개로 N : M 관계를 표현할 수 없음(연결 테이블을 추가해서 1 : N, N : 1 관계로 풀어내야함)
                • 객체는 컬렉션을 사용해서 객체 2개로 N : M 관계 가능
                • @JoinTable 로 연결 테이블 지정(연결 테이블이 생성되지만 컬럼을 추가할 수 없다)
                • N 대 M 매핑: 단방향, 양방향 가능
                • @ManyToMany 대신에 연결 테이블용 엔티티 추가하여 사용하자(연결 테이블을 엔티티로 승격) ==> @ManyToMany -> @OneToMany, @ManyToOne


        2. 단방향, 양방향
            - 테이블
                • 외래 키 하나로 양쪽 조인 가능
                • 사실 방향이라는 개념이 없음
            - 객체
                • 참조용 필드가 있는 쪽으로만 참조 가능
                • 한쪽만 참조하면 단방향
                • 양쪽이 서로 참조하면 양방향


        3. 연관관계의 주인
            - 테이블은 외래 키 하나로 두 테이블이 연관관계를 맺음
            - 객체 양방향 관계는 A->B, B->A 처럼 참조가 2군데
            - 객체 양방향 관계는 참조가 2군데 있음. 둘 중 테이블의 외래 키를 관리할 곳을 지정해야함
            - 연관관계의 주인: 외래 키를 관리하는 참조
            - 주인의 반대편: 외래 키에 영향을 주지 않음, 단순 조회만 가능
    */
}
